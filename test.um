// testing the tester            //
// the framework loops on itself //
// finish this haiku             //

import (
	"std.um"

	"toast.um"
)

fn passingTest1(ctx: ^toast::Context) {
	if !ctx.assertTrue(1 + 2 == 3, "math does not work") { return }
}

fn passingTest2(ctx: ^toast::Context) {
	f, err := std::fopen("toast.um", "rb")
	if !ctx.assertOk(err, "this should NOT HAPPEN") { return }
}

fn passingTest3(ctx: ^toast::Context) {
	if !ctx.assertEqualTypes(any(1), any(2), "how are they not numbers") { return }
}

fn passingTest4(ctx: ^toast::Context) {
	ctx.assertTrue(false)
	ctx.pass() // forced pass
}

fn failingTest1(ctx: ^toast::Context) {
	ctx.assertFalse(1 + 2 == 3, "math works")
	ctx.assertFalse(2 + 2 == 4, "math works again")
}

fn failingTest2(ctx: ^toast::Context) {
	f, err := std::fopen("lasjdlaskjdlaskjdalsdjalskdjlasjdlasjdl", "rb")
	if !ctx.assertOk(err, "this should, indeed, happen ğŸ‘") { return }
}

fn failingTest3(ctx: ^toast::Context) {
	if !ctx.assertEqualTypes(any(false), any(2),
		"thankfully they're not numbers-"+
		" well, no, one of them is a number but wtv") { return }
}

fn failingTest4(ctx: ^toast::Context) {
	ctx.assertTrue(false)
	// ctx.pass() // no forced pass???? idk
}

fn main() {
	var ctx: toast::Context

	ctx.registerTests({
		{ name: "failing test 1", func: failingTest1 },
		{ name: "failing test 2", func: failingTest2 },
	})

	ctx.registerTest("passing test 1", passingTest1)

	ctx.registerTests({
		{ name: "failing test 4", func: failingTest4 },
	})

	ctx.registerTests({
		{ name: "passing test 3", func: passingTest3 },
		{ name: "passing test 4", func: passingTest4 },
	})

	ctx.registerTest("failing test 3", failingTest3)

	ctx.registerTest("passing test 2", passingTest2)

	results := ctx.run()
	toast::printResults(results, {
		// noColor: true,
		// ascii: true,
		// noBulletpoints: true,
		filter: .allTests,
		noTotalRuntime: true,
	})
}
