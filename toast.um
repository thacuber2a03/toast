import "std.um"

const version* = "0.6.0"

type (
	TestFn* = fn(ctx: ^Context)

	TestEntry* = struct { name: str; func: TestFn }

	SingleTestResult* = struct {
		name: str
		locations: []std::ErrPos
		errors: []std::Err
		time: real
	}

	TestResults* = struct {
		data: []SingleTestResult
		totalRuntime: real
	}

	ContextInternal = struct {
		currentTestResult: ^SingleTestResult
		currentTestFunction: TestFn
	}

	Context* = struct { _: ContextInternal
		queuedTests: []TestEntry
		finished: bool
	}
)

/////////////////////////////////////////////////////////////////////////////////////

fn getStackFrame(i: int = 2): std::ErrPos {
	return std::error(-1).trace[i] // help
}

fn (c: ^Context) internalFail(msg: str, loc: std::ErrPos, error: str): bool {
	tr := c._.currentTestResult

	tr.errors = append(tr.errors, std::error(-1,
		error + (msg != "" ? ": " + msg : ""),
		c._.currentTestFunction
	))
	tr.locations = append(tr.locations, loc)

	return false
}

fn (c: ^Context) fail*(msg: str = ""): bool {
	return c.internalFail(msg, getStackFrame(), "failure")
}

// the only function that can override the result in this way
fn (c: ^Context) pass*(): bool {
	tr := c._.currentTestResult
	tr.errors = {}
	tr.locations = {}
	return true
}

fn (c: ^Context) assertBase(ok: bool, msg: str): bool {
	if !ok { c.internalFail(msg, getStackFrame(3), "assertion failed") }
	return ok
}

fn (c: ^Context) assertTrue*(b: bool, msg: str = ""): bool {
	return c.assertBase(b, msg)
}

fn (c: ^Context) assertFalse*(b: bool, msg: str = ""): bool {
	return c.assertBase(!b, msg)
}

fn (c: ^Context) assertOk*(err: std::Err, msg: str = ""): bool {
	if msg == "" {
		msg = sprintf("error code is not std::StdErr.ok (%d)", err.code)
	}
	return c.assertBase(err.code == 0, msg)
}

fn (c: ^Context) assertErr*(err: std::Err, msg: str = ""): bool {
	if msg == "" { msg = "error code is std::StdErr.ok" }
	return c.assertBase(err.code != 0, msg)
}

fn (c: ^Context) assertEqualTypes*(a, b: any, msg: str = ""): bool {
	if msg == "" { msg = sprintf("%v and %v have different types", a, b) }
	return c.assertBase(selftypeeq(a, b), msg)
}

/////////////////////////////////////////////////////////////////////////////////////

fn libraryInit()

fn (c: ^Context) registerTestEntry(entry: TestEntry) {
	libraryInit()

	e := sprintf("test already registered: '%s'", entry.name)

	for _, t^ in c.queuedTests { std::assert(t.name != entry.name, e) }

	c.queuedTests = append(c.queuedTests, entry)
}

fn (c: ^Context) registerTest*(name: str, func: TestFn) {
	c.registerTestEntry({name, func})
}

fn (c: ^Context) registerTests*(tests: []TestEntry) {
	for _, t in tests { c.registerTestEntry(t) }
}

fn (c: ^Context) run*(): TestResults {
	libraryInit()
	// TODO: should do this???
	std::assert(!c.finished, "attempt to re-run tests")

	var results: TestResults
	results.data = make([]SingleTestResult, len(c.queuedTests))

	for i, t^ in c.queuedTests {
		var r: SingleTestResult
		r.name = t.name

		c._.currentTestResult = &r

		// have as little ceremony as possible
		start := std::clock()
		t.func(c)
		time := std::clock() - start
		r.time = time

		results.data[i] = r
		results.totalRuntime += time
	}

	c.finished = true
	c._.currentTestResult = null

	return results
}

/////////////////////////////////////////////////////////////////////////////////////

type (
	StyleTestFilter = enum (uint8) {
		onlyFailedTests
		allTests
	}

	ResultPrintStyle* = struct {
		ascii, noColor: bool
		noBulletpoints: bool
		filter: StyleTestFilter
		noTotalRuntime: bool
	}
)

type Icon = enum { success; fail }

var (
	asciiIcons: map[Icon]str
	unicodeIcons: map[Icon]str
)

var libraryInited: bool
fn libraryInit() {
	if libraryInited { return }
	libraryInited = true

	unicodeIcons = {
		.success: "✓",
		.fail: "✗",
	}

	asciiIcons = {
		.success: "O",
		.fail: "X",
	}
}

fn printColorFor(i: Icon) {
	col := 0
	switch i {
	case .success: col = 32
	case .fail: col = 31
	}
	printf("\x1b[%dm", col)
}

fn turnOffColor() { printf("\x1b[m") }

// TODO: split this function in parts
fn printResults*(results: TestResults, style: ResultPrintStyle = {}) {
	libraryInit()

	if !style.noColor {
		style.noColor = std::getenv("NO_COLOR") != "" 
	}

	icons := style.ascii ? asciiIcons : unicodeIcons

	if !style.noBulletpoints {
		for _, t in results.data {
			state := len(t.errors) == 0 ? Icon.success : Icon.fail
			if !style.noColor { printColorFor(state) }
			printf("%s", icons[state])
			turnOffColor()
		}

		printf("\n\n")
	}

	var prevState: Icon
	for i, t in results.data {
		state := len(t.errors) == 0 ? Icon.success : Icon.fail

		if state == .success && style.filter == .onlyFailedTests { continue }

		if !style.noColor { printColorFor(state) }
		if i != 0 && prevState != state && state == .fail { printf("\n") }
		printf("%s %s  %.3fs", icons[state], t.name, t.time)

		if state == .fail {
			for i, res in t.errors {
				if !style.noColor { printColorFor(state) }
				l := t.locations[i]
				printf("\n%s", res.msg)
				turnOffColor()
				printf("\n%s:%d (%s)", l.file, l.line, l.func)
			}
			printf("\n")
		}

		printf("\n")
		prevState = state
	}

	turnOffColor()
	if !style.noTotalRuntime {
		printf("\ntotal suite runtime: %.3fs\n", results.totalRuntime)
	}
}
